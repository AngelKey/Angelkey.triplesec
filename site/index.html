<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TripleSec - Symmetric Encryption in the Browser combining AES, Salsa20, and Twofish</title>
    <meta charset="utf-8">
    <link  href="css/bootstrap.min.css" rel="stylesheet">
    <link  href="css/site.css" rel="stylesheet">
    <link  href='http://fonts.googleapis.com/css?family=Montserrat+Alternates:400,700' rel='stylesheet' type='text/css'>
    <script type="text/javascript"   src="js/triplesec.js"></script>
    <script type="text/javascript"   src="js/jquery.js"></script>
    <script type="text/javascript"   src="js/bootstrap.min.js"></script>
    <script type="text/javascript"   src="js/iced-coffee.js"></script>
    
    <script type="text/coffeescript">

      $ ->
        textarea_auto = (ta) ->
          ta.style.overflow = 'hidden'
          ta.style.height   = 0
          ta.style.height   = "#{25 + Math.min(600,Math.max(ta.scrollHeight, 50))}px"

        input_change = ->
          textarea_auto $('#demo-input-data')[0]
          v = $('#demo-input-data').val()
          k = $('#demo-input-key').val()
          $('.btn-encrypt, .btn-decrypt').prop('disabled', true)
          if v and v.length and k and k.length
            $('.btn-encrypt').prop('disabled', false)
            if (v.match /// ^ [a-f0-9]+ $///i ) and not (v.length % 2)
              $('.btn-decrypt').prop('disabled', false)

        progress = []

        reset_progress = (msg) ->
          progress = []
          $("#progress-summary").html (msg or '')

        progress_hook = (p) ->
          if (progress.length) and (progress[progress.length-1].what is p.what)
            progress[progress.length-1] = p
          else
            progress.push p
          h = ""
          h += "<li>#{pr.what} #{pr.i}/#{pr.total}</li>" for pr in progress
          $("#progress-summary").html h

        $('#demo-input-data').on 'change',  -> input_change()
        $('#demo-input-data').on 'keyup',   -> input_change()
        $('#demo-input-key').on  'change',  -> input_change()
        $('#demo-input-key').on  'keyup',   -> input_change()


        $('.btn-encrypt').on 'click', =>
          reset_progress()
          $('.btn-encrypt, .btn-decrypt').prop('disabled', true)
          data   = new triplesec.Buffer $('#demo-input-data').val()
          key    = new triplesec.Buffer $('#demo-input-key').val()
          await triplesec.encrypt {
            data: data
            key:  key
            rng:  triplesec.rng
            progress_hook: progress_hook
          }, defer err, out
          await setTimeout defer(), 5
          if err
            reset_progress "<li>#{err}</li>"
          else
            hex = out.toString 'hex'          
            $("#demo-input-data").val hex
            textarea_auto $("#demo-input-data")[0]
          input_change()

        $('.btn-decrypt').on 'click', =>
          reset_progress()
          $('.btn-encrypt, .btn-decrypt').prop('disabled', true)
          data   = new triplesec.Buffer $('#demo-input-data').val(), 'hex'
          key    = new triplesec.Buffer $('#demo-input-key').val()
          await triplesec.decrypt {
            data: data
            key:  key
            progress_hook: progress_hook
          }, defer err, out
          await setTimeout defer(), 5
          if err
            reset_progress "<li>#{err}</li>"
          else
            txt = out.toString()
            $("#demo-input-data").val txt
            textarea_auto $("#demo-input-data")[0]
          input_change()

        textarea_auto $("#demo-input-data")[0]
    </script>
  </head>
  <body>
    <div class="container">

      <div class="row outer-grid">
        <div class="col-xs-3 col-md-2">
          <img src="img/logo.png" class="img-responsive">
        </div><!-- /.outer-grid's 1st column -->
        <div class="col-xs-9 col-md-10">

          <div class="brand">
            TripleSec
          </div>

          <div class="row">
            
            <div class="col-sm-8 intro">
              <blockquote>
                &ldquo;the NSA works with security product vendors to ensure that commercial encryption products are broken in secret ways that only it knows about.&rdquo;
                - Bruce Schneier, 9/13
              </blockquote>

              <p>
                <b>Governments wield great power</b>. Consider:
              </p>
              <ul>
                <li>the USA may compel websites &amp; businesses to "cooperate"</li>
                <li>the NSA may have already broken a popular cipher</li>
              </ul>
              <p>
                If you're a programmer and wish to store user data that <u>only the user can read</u> -- excluding both you and governments -- you must 
                encrypt in the browser or client app with care; you should avoid single encryption algorithms (possibly broken) and
                provided sources of entropy (possibly intentionally weak).
              </p>
              <p>
                <b>TripleSec</b> is a simple, open-source symmetric encryption library for the browser and Node.js. It aims for unbreakable encryption
                 using
                <a href="http://en.wikipedia.org/wiki/Salsa20" class="salsa20">Salsa 20</a>, 
                <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard" class="aes">AES</a>, 
                and <a href="http://en.wikipedia.org/wiki/Twofish" class="twofish">Twofish</a>,
                so that a compromise of 1 or 2 of the ciphers will expose nothing. A good source of
                cryptographically-strong pseudorandomness is crucial our construction's security, so
                TripleSec's implementation
                collects extra entropy from your computer, beyond the "provided" <code>window.crypto.getRandomValues</code>
                in browsers and <code>crypto.rng</code> in Node.js.
              </p>
              <p>
                In other words, <b>TripleSec</b> should work unless <i>all 3</i> of the algorithms have fallen. A dark, dark day that would be.
              </p>
            </div>
            <div class="col-sm-4">

            </div>

          </div>
          <!-- /.row -->


          <div class="demo">

            <h3>Demo</h3>

            <div class="well">

              <form class="form-horizontal" role="form">
                <div class="form-group">
                  <div class="col-sm-7">
                    <textarea class="form-control" rows="5" placeholder="input" id='demo-input-data'></textarea>
                  </div>
                  <div class="col-sm-5">
                    <div class="row">
                      <div class="col-sm-8">
                        <input type="text" class="form-control" placeholder="key (password)" id='demo-input-key'>
                        <div id="progress-summary">
                        </div>
                      </div>
                      <div class="col-sm-4">
                        <div class="btn-group-vertical">
                          <button class="btn btn-encrypt btn-default" type="button" disabled="true">Encrypt</button>
                          <button class="btn btn-decrypt btn-default" type="button" disabled="true">Decrypt</button>
                        </div>
                      </div>
                    </div><!-- /.row -->
                  </div>
                </div>
              </form>

              <div class="encryption-output" style="display:none;">
                <h5>Output</h5>
                <textarea class="output-code form-control" id="demo-output-data"></textarea>
              </div>


            </div>

          </div>
          <!-- /.demo -->

          <div class="installation subsection">
            <h3>Installation</h3>
            <p>
              For the browser, <a href="js/triplesec.js">download triplesec.js</a>, then <code>&lt;script src="triplesec.js"&gt;&lt;/script&gt;</code>. 
            </p>
            <p>
              In node, <code>npm install triplesec</code>.
            </p>
          </div>

          <div class="how-to-use subsection">
            <h3>How to Use It</h3>
            <p>
            Encryption is performed by the <code>encrypt</code> function. It is non-blocking on the CPU
            and calls back with <code>(err, buffer)</code>.
            </p>

            <!--

                SAMPLE CODE PANED SECTION

            -->


            <ul class="nav nav-pills pull-right">
              <li class="pull-right active"><a href="#encrypt-coffeescript" data-toggle="tab">CoffeeScript</a></li>
              <li class="pull-right"><a href="#encrypt-javascript"     data-toggle="tab">JavaScript</a></li>
            </ul>

            <div class="tab-content">
              <div class="tab-pane" id="encrypt-javascript">

                <pre>triplesec.encrypt ({

    data:          new triplesec.Buffer('Pssst. I believe I love you.'),
    key:           new triplesec.Buffer('top-secret-pw'),
    progress_hook: function (step, iterations, i) { /* ... */ }

}, function(err, buff) {
  
    if (! err) { 
        var ciphertext = buff.toString('hex');
    }

});</pre>
              </div><!-- /.tab-pane -->

              <div class="tab-pane active" id="encrypt-coffeescript">

                <pre>triplesec.encrypt

    data:          new triplesec.Buffer 'Pssst. I believe I love you.'
    key:           new triplesec.Buffer 'top-secret-pw'
    progress_hook: (step, iterations, i) -> # ...

, (err, buff) ->

    ciphertext = buff.toString 'hex' unless err</pre>
              </div><!-- /.tab-pane -->
            </div><!-- /.tab-content -->

          <!--

              END PANED SECTION

          -->

              <p>
                TripleSec's <code>decrypt</code> is painless.
              </p>

            <!--

                SAMPLE CODE PANED SECTION

            -->

            <ul class="nav nav-pills pull-right">
              <li class="pull-right active"><a href="#decrypt-coffeescript" data-toggle="tab">CoffeeScript</a></li>
              <li class="pull-right"><a href="#decrypt-javascript"     data-toggle="tab">JavaScript</a></li>
            </ul>

            <div class="tab-content">
              <div class="tab-pane" id="decrypt-javascript">


          <pre>triplesec.decrypt ({

    data:          new triplesec.Buffer(ciphertext, "hex"),
    key:           new triplesec.Buffer('top-secret-pw'),    
    progress_hook: function (step, iterations, i) { /* ... */ }

}, function (err, buff) {

    if (! err) { 
        console.log(buff.toString());
    }  

});

var plaintext = buff.toString();</pre>
              </div><!-- /.tab-pane -->
              <div class="tab-pane active" id="decrypt-coffeescript">


          <pre>triplesec.decrypt

    data:          new triplesec.Buffer ciphertext, 'hex'
    key:           new triplesec.Buffer 'top-secret-pw'
    progress_hook: (step, iterations, i) -> # ...

, (err, buff) ->

    console.log buff.toString() unless err</pre>
              </div><!-- /.tab-pane -->              
            </div><!-- /.tab-content -->

          </div><!-- /.how-to-use -->

          <div class="design subsection">
            <h3>Algorithm Design</h3>

            <p>The TripleSec library encrypts data in four steps:
              <ol>

                <li>
                  <b>Key derivation.</b> Given a user-provided password, and a
                  random salt value, generate four separate secret keys, one
                  for each cipher (see Step 3), and a final key for
                  signing the ciphertext (see Step 4).  This "key stretching" is done via
                  <a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> 
                  using the <a href="http://en.wikipedia.org/wiki/Sha-2">SHA-512</a> 
                  hash primitive.  The output of this step is four seperate keys, 
                  used below.
                </li>

                <li>
                  <b>Initial value (IV) generation.</b> A random number generator is queried 
                  to produce an initial for each of the three ciphers: a 192-bit
                  IV for Salsa20; a 128-bit IV for Twofish; and a 128-bit
                  IV for AES.
                </li>

                <li>
                  <b>Cascading encryption.</b> Each of the ciphers runs with the keys generated
                  in Step 1, and the IVs generated in Step 2.

                  <ol>
                    <li>
                      <p><b>Salsa20.</b> The innermost cipher is a Salsa20 variant called <a href="http://cr.yp.to/papers.html#xsalsa">XSalsa20</a>. Like Salsa20, XSalsa20 is a stream
                      cipher, meaning it can encrypt input texts of arbitrary length without a 
                      a block cipher mode of operation.  XSalsa20 takes a 192-bit nonce
                      rather than Salsa20's 64-bit nonce, but is provably as secure.  We chose
                      XSalsa20 over Salsa20 for the sake of excess paranoia.
                      Given a key, and an IV, XSalsa20 generates a random pad,
                      which is then XOR'ed with the input message.  This step of the algorithm
                      outputs the concatenation of the IV and the result of the XOR operation.
                    </li>

                    <li><b>Twofish-CTR.</b> The output of the previous step 
                      (call it <i>C<sub>1</sub></i>) is the input
                      of this step, which uses Twofish running in <a href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29">CTR</a> mode.
                      Let <i>R<sub>2</sub></i> be the the IV generated for Twofish in Step 2.
                      Twofish-CTR works by encrypting <i>R<sub>2</sub></i>, <i>R<sub>2</sub>+1</i>, <i>R<sub>2</sub>+2</i>,...
                      with Twofish, and concatenating the result to yield a pad the size
                      of <i>C<sub>1</sub></i>. Call this pad <i>P<sub>2</sub></i> .
                      Output (<i>R<sub>2</sub></i> || (<i>P<sub>2</sub></i> ⊕ <i>C<sub>1</sub></i>)),
                      where "||" denotes concatenation, and "⊕" denotes XOR.
                    </li>

                    <li><b>AES-256-CTR.</b> In the final encryption step, apply AES-256 running
                      in CTR mode to the output of the Twofish-CTR step.  As above,
                      first XOR the output of the previous step with the pad output
                      by AES-256-CTR.  Then prepend the IV used.
                    </li>
                  </ol>
                </li>

                <li>
                  <b>HMAC (or "sign") the ciphertext.</b> Finally, TripleSec "signs" the ciphertext
                  to ensure that no adversary tampers with it. The data to be signed
                  is everything generated to date: a small header that encapsulates the version
                  of the algorithm (now at <tt>1</tt>); the salt used in key derivation; and
                  the output of the AES stage of the cascading encryption above.  TripleSec uses
                  <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a> with SHA-512 to prepare a mac.  The final output is a concatenation of:
                  the header; the salt; the signature; and the outermost ciphertext.
                </li>

              </ol>
            </p>

            <p>
              Though this is not the exact composition suggested by Schneier in
              <i>Applied Cryptography</i> (Section 15.8 in the Second Edition), it is
              close.  TripleSec never uses the output of one block cipher as input into the next,
              which theoretically might allow a crack of one cipher to be used to crack
              another. Rather, by merit of CTR mode, the three ciphers run on statistcally 
              independent IVs, so a crack of one will not spread up or down the chain.
              The TripleSec technique takes one futher step not suggested by Schneier,
              which is to protect the inner IVs with the outer encryption algorithms, and only
              exposing the outermost IV in the clear. Though we can't prove this makes 
              the scheme more secure, it seems like a reasonable idea: why reveal cipher
              inputs if we don't have to? Finally, this algorithm has the added advantage
              that the output ciphertext only increases by a constant additive term (i.e.,
              the lengths of the header, the salt, the HMAC and the three IVs).  Schneier's
              technique inflates ciphertexts by a factor N, where N is the number of 
              independent ciphers used.
            </p>

          </div><!-- /.design -->

          <div class="questions subsection">
            <h3>Anticipated Questions</h3>
            <div class="question">
              <h5>What's triplesec.Buffer?</h5>
              <p class="answer">
                It is a wrapper around either Node.js's Buffer or a browser equivalent. When you generate
                encrypted data, you can use the output buffer however you like. In our above examples, we converted
                to and from hex strings.
              </p>
              <h5>How does TripleSec generate randomness/entropy? Can I provide my own?</h5>
              <p class="answer">
                In the browser, TripleSec uses <code>window.crypto.getRandomValues</code> and in Node it uses <code>crypto.rng</code>.
                For fear of a compromise -- let's say your browser's author has inserted a weak version of one of these in exchange
                for some honeypot sex -- 
                TripleSec seeds further
                with <a href="https://github.com/keybase/more-entropy">more-entropy (explained here in more detail)</a>, which does its own timing of a great
                number of math operations.
              </p>
              <p class="answer">
                You may alternatively provide your own random number generator for encryption. Pass an <code>rng</code> function
                along with your other data. This function should behave just like [...].
              </p>
              <h5>How are passphrases salted?</h5>
              <p class="answer">
                Max to write this.
              </p>
              <h5>Can I encrypt files with it, in the browser?</h5>
              <p class="answer">
                Yes, using HTML5 features you can access file data without uploading it to a server. Note that TripleSec is not super fast.
              </p>
              <h5>Why isn't library X good enough (for X in Clipperz, Forge, SJCL, CryptoJS, etc.)?</h5>
              <p class="answer">
                 There are lots of great JS Crypto libraries out there, and we've borrowed from some to build TripleSec.
                 But combining cryptographic primitives to achieve 
                 <a href="http://en.wikipedia.org/wiki/Ciphertext_indistinguishability">IND-CCA2</a> security involves many fussy
                 decisions and much avoidance of implementation pitfalls.  We want all to have access to higher-level primitives that can
                 be applied with little thought.  Hence TripleSec!  
              </p>
              <h5>Is this provably secure?</h5>
              <p class="answer">
                We don't know. We think that TripleSec can only be broken if all three algorithms are broken, but 
                we don't have a proof. We furthmore think that TripleSec is non-malleable (and hence IND-CCA2 secure)
                due to the HMAC step. Current events and insider leaks are changing all cryptographic assumptions.
                A few months ago, TripleSec's cryptographic redudancy would be seen as a kinky fettish.
                But going forward, double- or triple-protection seems like a good
                idea, and we expect that proofs and/or proven constructions for cascading encryption will 
                be available shortly. 
              </p>
            </div>
          </div>

          <div class="outside-javascript subsection">
            <h3>Implementations Outside JavaScript</h3>
            <p>
              We welcome ports! We will list them here.
            </p>
          </div>

          <div class="whos-using subsection">
            <h3>Who's Using it?</h3>
            <p>
              For starters, we are (<a href="http://www.twitter.com/maxtaco">Max Krohn</a> &amp; <a href="http://www.twitter.com/malgorithms">Chris Coyne</a>). We're working on an unrelated site
              now, and TripleSec will be used to encrypt our users' keys.
            </p>
            <p>
              If you use TripleSec for something public, please contact us. We'll mention you here. 
            </p>
            <p>
              Here are some ideas, in case you're feeling ambitious:
            </p>
            <ul>
              <li>a TripleSec browser extension for highlighting and encrypting/decrypting text on any page</li>
              <li>diary/journal</li>
              <li>key storage</li>
              <li>password manager</li>
              <li>Bitcoin wallet</li>
            </ul>
          </div>

          <div class="whos-using subsection">
            <h3>Can I help?</h3>
            <p>
              Please! Above all else, we encourage review of both our algorithm and <a href="http://github.com/keybase/triplesec">the source code</a>. If anyone has a spare proof of IND-CCA2 security sitting around the house, we'd love to it!
            </p>
          </div>

        </div><!-- /.outer-grid's 2nd column -->
      </div><!-- /.outer-grid -->

    </div><!-- /.container -->

  </body>
</html>