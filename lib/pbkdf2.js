// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var HMAC, PBKDF2, WordArray, pkbdf2;



  HMAC = require('./hmac').HMAC;

  WordArray = require('./wordarray').WordArray;

  exports.PBKDF2 = PBKDF2 = (function() {
    function PBKDF2(_arg) {
      this.key = _arg.key, this.salt = _arg.salt, this.c = _arg.c;
      this.prf = new HMAC(this.key);
    }

    PBKDF2.prototype.PRF = function(input) {
      this.prf.reset();
      return this.prf.finalize(input);
    };

    PBKDF2.prototype.gen_T_i = function(i) {
      var U, ret, seed, _i, _ref;
      seed = this.salt.clone().concat(new WordArray([i]));
      U = this.PRF(seed);
      ret = U.clone();
      for (i = _i = 1, _ref = this.c; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        U = this.PRF(U);
        ret.xor(U, {});
      }
      return ret;
    };

    PBKDF2.prototype.gen = function(len) {
      var bs, flat, i, n, words, _ref;
      bs = this.prf.get_output_size();
      n = Math.ceil(len / bs);
      words = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          _results.push(this.gen_T_i(i).words);
        }
        return _results;
      }).call(this);
      flat = (_ref = []).concat.apply(_ref, words);
      return new WordArray(flat, len);
    };

    return PBKDF2;

  })();

  exports.pbkdf2 = pkbdf2 = function(_arg) {
    var c, dkLen, key, salt;
    key = _arg.key, salt = _arg.salt, c = _arg.c, dkLen = _arg.dkLen;
    return (new PBKDF2({
      key: key,
      salt: salt,
      c: c
    })).gen(dkLen);
  };

}).call(this);
