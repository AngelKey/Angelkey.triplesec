// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Cipher, Counter, KeyStream, WordArray, encrypt;



  WordArray = require('./wordarray').WordArray;

  exports.Counter = Counter = (function() {
    Counter.prototype.WORD_MAX = 0xffffffff;

    function Counter(_arg) {
      var i, len, value;
      value = _arg.value, len = _arg.len;
      this._value = value != null ? value.clone() : (len == null ? len = 2 : void 0, new WordArray((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()));
    }

    Counter.prototype.inc = function() {
      var go, i;
      go = true;
      i = this._value.words.length - 1;
      while (go && i >= 0) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i--;
      }
      return this;
    };

    Counter.prototype.inc_le = function() {
      var go, i;
      go = true;
      i = 0;
      while (go && i < this._value.words.length) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i++;
      }
      return this;
    };

    Counter.prototype.get = function() {
      return this._value;
    };

    Counter.prototype.copy = function() {
      return this._value.clone();
    };

    return Counter;

  })();

  KeyStream = (function() {
    function KeyStream(_arg) {
      this.block_cipher = _arg.block_cipher, this.iv = _arg.iv, this.len = _arg.len;
      if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {
        throw new Error("IV is wrong length (" + this.iv.sigBytes + ")");
      }
    }

    KeyStream.prototype.generate_input = function() {
      var ctr, flat, i, pad_words, _ref;
      this.nblocks = Math.ceil(this.len / this.block_cipher.blockSize);
      ctr = new Counter({
        value: this.iv
      });
      pad_words = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= nblocks ? _i < nblocks : _i > nblocks; i = 0 <= nblocks ? ++_i : --_i) {
          _results.push(ctr.inc().copy().words);
        }
        return _results;
      })();
      flat = (_ref = []).concat.apply(_ref, pad_words);
      return this.keystream = new WordArray(flat, this.len);
    };

    KeyStream.prototype.encrypt = function() {
      var i, _i, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.len, _ref1 = this.block_cipher.blockSize; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        _results.push(this.block_cipher.encryptBlock(this.pad.words, i));
      }
      return _results;
    };

    KeyStream.prototype.run = function() {
      this.generate_input();
      this.encrypt();
      return this.keystream;
    };

    return KeyStream;

  })();

  exports.gen_keystream = function(_arg) {
    var block_cipher, iv, len;
    block_cipher = _arg.block_cipher, iv = _arg.iv, len = _arg.len;
    return (new KeyStream({
      block_cipher: block_cipher,
      iv: iv,
      len: len
    })).run();
  };

  exports.Cipher = Cipher = (function() {
    function Cipher(_arg) {
      this.block_cipher = _arg.block_cipher, this.iv = _arg.iv;
      this.bsiw = this.block_cipher.blockSize / 4;
      if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {
        throw new Error("IV is wrong length (" + this.iv.sigBytes + ")");
      }
      this.ctr = new Counter({
        value: this.iv
      });
    }

    Cipher.prototype.encryptBlock = function(word_array, dst_offset) {
      var n_words, pad;
      if (dst_offset == null) {
        dst_offset = 0;
      }
      pad = this.ctr.copy();
      this.ctr.inc();
      this.block_cipher.encryptBlock(pad.words);
      n_words = Math.min(word_array.words.length - dst_offset, this.bsiw);
      word_array.xor(pad, {
        dst_offset: dst_offset,
        n_words: n_words
      });
      return this.bsiw;
    };

    Cipher.prototype.encrypt = function(word_array) {
      var i, _i, _ref, _ref1;
      for (i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        this.encryptBlock(word_array, i);
      }
      return word_array;
    };

    return Cipher;

  })();

  exports.encrypt = encrypt = function(_arg) {
    var block_cipher, input, iv;
    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input;
    return (new Cipher({
      block_cipher: block_cipher,
      iv: iv
    })).encrypt(input);
  };

}).call(this);
