// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Base, Concat, HMAC, SHA3, SHA512, XOR, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  HMAC = require('./hmac').HMAC;

  SHA512 = require('./sha512').SHA512;

  SHA3 = require('./sha3').SHA3;

  Base = (function() {
    Base.keySize = HMAC.keySize;

    Base.prototype.keySize = Base.keySize;

    Base.outputSize = HMAC.outputSize;

    Base.prototype.outputSize = Base.outputSize;

    function Base(key, klasses) {
      var klass;
      if (klasses == null) {
        klasses = [SHA512, SHA3];
      }
      this.hashers = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = klasses.length; _i < _len; _i++) {
          klass = klasses[_i];
          _results.push(new HMAC(key, klass));
        }
        return _results;
      })();
    }

    Base.prototype.reset = function() {
      var h, _i, _len, _ref;
      _ref = this.hashers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        h = _ref[_i];
        h.reset();
      }
      return this;
    };

    Base.prototype.update = function(w) {
      var h, _i, _len, _ref;
      _ref = this.hashers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        h = _ref[_i];
        h.update(w);
      }
      return this;
    };

    Base.prototype.scrub = function() {
      var h, _i, _len, _ref;
      _ref = this.hasher;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        h = _ref[_i];
        h.scrub();
      }
      return this;
    };

    Base.prototype.finalize = function(w) {
      var h, hashes, out, _i, _len, _ref;
      hashes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.hashers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          h = _ref[_i];
          _results.push(h.finalize(w));
        }
        return _results;
      }).call(this);
      out = hashes[0];
      _ref = hashes.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        h = _ref[_i];
        this.coalesce(out, h);
        h.scrub();
      }
      return out;
    };

    return Base;

  })();

  exports.Concat = Concat = (function(_super) {
    __extends(Concat, _super);

    function Concat() {
      _ref = Concat.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Concat.prototype.coalesce = function(out, h) {
      return out.concat(h);
    };

    Concat.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new Concat(key)).finalize(input);
    };

    return Concat;

  })(Base);

  exports.XOR = XOR = (function(_super) {
    __extends(XOR, _super);

    function XOR() {
      _ref1 = XOR.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    XOR.prototype.coalesce = function(out, h) {
      return out.xor(h, {});
    };

    XOR.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new XOR(key)).finalize(input);
    };

    return XOR;

  })(Base);

}).call(this);
