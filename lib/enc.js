// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var AES, Base, Encryptor, SHA512, TwoFish, V, WordArray, ctr, encrypt, hmac, pbkdf2, salsa20, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  salsa20 = require('./salsa20');

  AES = require('./aes').AES;

  TwoFish = require('./twofish').TwoFish;

  ctr = require('./ctr');

  hmac = require('./hmac');

  SHA512 = require('./sha512').SHA512;

  pbkdf2 = require('./pbkdf2').pbkdf2;

  util = require('./util');

  exports.V = V = {
    "1": {
      header: [0x1c94d7de, 1],
      pbkdf2_iters: 2048,
      salt_size: 8
    }
  };

  exports.Base = Base = (function() {
    function Base(_arg) {
      var key;
      key = _arg.key;
      this.key = WordArray.from_buffer(key);
      this.derived_keys = {};
    }

    Base.prototype.pbkdf2 = function(salt) {
      var end, i, k, key, keys, len, lens, raw, salt_hex, tot, v;
      salt_hex = salt.to_hex();
      if ((k = this.derived_keys[salt_hex]) != null) {
        return k;
      }
      lens = {
        hmac: hmac.HMAC.keySize,
        aes: AES.keySize,
        twofish: TwoFish.keySize,
        salsa20: salsa20.Salsa20.keySize
      };
      tot = 0;
      for (k in lens) {
        v = lens[k];
        tot += v;
      }
      key = this.key.clone();
      raw = pbkdf2({
        key: key,
        salt: salt,
        c: this.version.pbkdf2_iters,
        dkLen: tot
      });
      keys = {};
      i = 0;
      for (k in lens) {
        v = lens[k];
        len = v / 4;
        end = i + len;
        keys[k] = new WordArray(raw.words.slice(i, end));
        i = end;
      }
      this.derived_keys[salt_hex] = keys;
      return keys;
    };

    Base.prototype.sign = function(_arg) {
      var input, key, out, salt;
      input = _arg.input, key = _arg.key, salt = _arg.salt;
      input = (new WordArray(this.version.header)).concat(salt).concat(input);
      out = hmac.sign({
        key: key,
        input: input
      });
      return out;
    };

    Base.prototype.run_salsa20 = function(_arg) {
      var ct, input, iv, key, output_iv;
      input = _arg.input, key = _arg.key, iv = _arg.iv, output_iv = _arg.output_iv;
      ct = salsa20.encrypt({
        input: input,
        key: key,
        iv: iv
      });
      if (output_iv) {
        return iv.clone().concat(ct);
      } else {
        return ct;
      }
    };

    Base.prototype.run_twofish = function(_arg) {
      var block_cipher, input, iv, key;
      input = _arg.input, key = _arg.key, iv = _arg.iv;
      block_cipher = new TwoFish(key);
      return iv.clone().concat(ctr.encrypt({
        block_cipher: block_cipher,
        iv: iv,
        input: input
      }));
    };

    Base.prototype.run_aes = function(_arg) {
      var block_cipher, input, iv, key;
      input = _arg.input, key = _arg.key, iv = _arg.iv;
      block_cipher = new AES(key);
      return iv.clone().concat(ctr.encrypt({
        block_cipher: block_cipher,
        iv: iv,
        input: input
      }));
    };

    Base.prototype.scrub = function() {
      var key, key_ring, salt, _ref, _results;
      this.key.scrub();
      _ref = this.derived_keys;
      _results = [];
      for (salt in _ref) {
        key_ring = _ref[salt];
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = key_ring.length; _i < _len; _i++) {
            key = key_ring[_i];
            _results1.push(key.scrub());
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Base;

  })();

  exports.Encryptor = Encryptor = (function(_super) {
    __extends(Encryptor, _super);

    Encryptor.prototype.version = V[1];

    function Encryptor(_arg) {
      var key;
      key = _arg.key, this.rng = _arg.rng;
      Encryptor.__super__.constructor.call(this, {
        key: key
      });
      this.last_salt = null;
    }

    Encryptor.prototype.pick_random_ivs = function() {
      var iv_lens, ivs, k, v;
      iv_lens = {
        aes: AES.ivSize,
        twofish: TwoFish.ivSize,
        salsa20: salsa20.Salsa20.ivSize
      };
      ivs = {};
      for (k in iv_lens) {
        v = iv_lens[k];
        ivs[k] = WordArray.from_buffer(this.rng(v));
      }
      return ivs;
    };

    Encryptor.prototype.resalt = function() {
      this.salt = WordArray.from_buffer(this.rng(this.version.salt_size));
      this.keys = this.pbkdf2(this.salt);
      return this;
    };

    Encryptor.prototype.run = function(data) {
      var ct1, ct2, ct3, ivs, pt, sig;
      if (this.salt == null) {
        this.resalt();
      }
      ivs = this.pick_random_ivs();
      pt = WordArray.from_buffer(data);
      ct1 = this.run_salsa20({
        input: pt,
        key: this.keys.salsa20,
        iv: ivs.salsa20,
        output_iv: true
      });
      ct2 = this.run_twofish({
        input: ct1,
        key: this.keys.twofish,
        iv: ivs.twofish
      });
      ct3 = this.run_aes({
        input: ct2,
        key: this.keys.aes,
        iv: ivs.aes
      });
      sig = this.sign({
        input: ct3,
        key: this.keys.hmac,
        salt: this.salt
      });
      return (new WordArray(this.version.header)).concat(this.salt).concat(sig).concat(ct3).to_buffer();
    };

    return Encryptor;

  })(Base);

  exports.encrypt = encrypt = function(_arg) {
    var data, enc, key, ret, rng;
    key = _arg.key, data = _arg.data, rng = _arg.rng;
    enc = new Encryptor({
      key: key,
      rng: rng
    });
    ret = enc.run(data);
    util.scrub_buffer(data);
    enc.scrub();
    return ret;
  };

}).call(this);
