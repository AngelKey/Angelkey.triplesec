// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var HMAC_SHA256, Salsa20InnerCore, Scrypt, WordArray, blkcpy, blkxor, default_delay, iced, le32dec, le32enc, pbkdf2, scrub_vec, scrypt, ui8a_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  HMAC_SHA256 = require('./hmac').HMAC_SHA256;

  pbkdf2 = require('./pbkdf2').pbkdf2;

  Salsa20InnerCore = require('./salsa20').Salsa20InnerCore;

  _ref = require('./wordarray'), ui8a_to_buffer = _ref.ui8a_to_buffer, WordArray = _ref.WordArray;

  _ref1 = require('./util'), default_delay = _ref1.default_delay, scrub_vec = _ref1.scrub_vec;

  blkcpy = function(D, S, d_offset, s_offset, len) {
    return D.set(S.subarray(0x40 * s_offset, 0x40 * (s_offset + len)), 0x40 * d_offset);
  };

  blkxor = function(D, S, s_offset, len) {
    var i, _i;
    s_offset <<= 6;
    len <<= 6;
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      D[i] ^= S[i + s_offset];
    }
    return true;
  };

  le32dec = function(B) {
    return (B[0] | (B[1] << 8) | (B[2] << 16)) + (B[3] * 0x1000000);
  };

  le32enc = function(B, w) {
    B[0] = w & 0xff;
    B[1] = (w >> 8) & 0xff;
    B[2] = (w >> 16) & 0xff;
    return B[3] = (w >> 24) & 0xff;
  };

  Scrypt = (function() {
    function Scrypt(_arg) {
      this.N = _arg.N, this.r = _arg.r, this.p = _arg.p, this.c = _arg.c, this.klass = _arg.klass;
      this.N || (this.N = Math.pow(2, 8));
      this.r || (this.r = 16);
      this.p || (this.p = 2);
      this.c || (this.c = 1);
      this.klass || (this.klass = HMAC_SHA256);
      this.X64_tmp = new Uint8Array(64);
      this.s20ic = new Salsa20InnerCore(8);
    }

    Scrypt.prototype.salsa20_8 = function(B) {
      var B32, X, b, i, x, _i, _j, _len, _len1, _results;
      B32 = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 16; i = ++_i) {
          _results.push(le32dec(B.subarray(i * 4)));
        }
        return _results;
      })();
      X = this.s20ic._core(B32);
      for (i = _i = 0, _len = X.length; _i < _len; i = ++_i) {
        x = X[i];
        B32[i] += x;
      }
      _results = [];
      for (i = _j = 0, _len1 = B32.length; _j < _len1; i = ++_j) {
        b = B32[i];
        _results.push(le32enc(B.subarray(i * 4), b));
      }
      return _results;
    };

    Scrypt.prototype.pbkdf2 = function(_arg, cb) {
      var c, dkLen, key, progress_hook, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, salt = _arg.salt, c = _arg.c, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/scrypt.iced",
          funcname: "Scrypt.pbkdf2"
        });
        pbkdf2({
          key: key,
          salt: salt,
          c: c,
          dkLen: dkLen,
          klass: _this.klass,
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return wa = arguments[0];
            };
          })(),
          lineno: 64
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(wa);
      });
    };

    Scrypt.prototype.blockmix_salsa8 = function(B, Y) {
      var X, i, _i, _j, _k, _ref2, _ref3, _ref4, _results;
      X = this.X64_tmp;
      blkcpy(X, B, 0, 2 * this.r - 1, 1);
      for (i = _i = 0, _ref2 = 2 * this.r; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        blkxor(X, B, i, 1);
        this.salsa20_8(X);
        blkcpy(Y, X, i, 0, 1);
      }
      for (i = _j = 0, _ref3 = this.r; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        blkcpy(B, Y, i, i * 2, 1);
      }
      _results = [];
      for (i = _k = 0, _ref4 = this.r; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; i = 0 <= _ref4 ? ++_k : --_k) {
        _results.push(blkcpy(B, Y, i + this.r, i * 2 + 1, 1));
      }
      return _results;
    };

    Scrypt.prototype.integerify = function(B) {
      return le32dec(B) & (this.N - 1);
    };

    Scrypt.prototype.smix = function(_arg, cb) {
      var B, V, X, XY, Y, i, j, lim, progress_hook, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      B = _arg.B, V = _arg.V, XY = _arg.XY, progress_hook = _arg.progress_hook;
      X = XY;
      lim = 2 * this.r;
      Y = XY.subarray(0x40 * lim);
      blkcpy(X, B, 0, 0, lim);
      i = 0;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _this.N)) {
            return _break();
          } else {
            stop = Math.min(_this.N, i + 128);
            while (i < stop) {
              blkcpy(V, X, lim * i, 0, lim);
              _this.blockmix_salsa8(X, Y);
              i++;
            }
            if (typeof progress_hook === "function") {
              progress_hook(i);
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/scrypt.iced",
                funcname: "Scrypt.smix"
              });
              default_delay(0, 0, __iced_deferrals.defer({
                lineno: 130
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        i = 0;
        (function(__iced_k) {
          var _results, _while;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(i < _this.N)) {
              return _break();
            } else {
              stop = Math.min(_this.N, i + 128);
              while (i < stop) {
                j = _this.integerify(X.subarray(0x40 * (lim - 1)));
                blkxor(X, V, j * lim, lim);
                _this.blockmix_salsa8(X, Y);
                i++;
              }
              if (typeof progress_hook === "function") {
                progress_hook(i + _this.N);
              }
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/scrypt.iced",
                  funcname: "Scrypt.smix"
                });
                default_delay(0, 0, __iced_deferrals.defer({
                  lineno: 146
                }));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        })(function() {
          blkcpy(B, X, 0, 0, lim);
          return cb();
        });
      });
    };

    Scrypt.prototype.run = function(_arg, cb) {
      var B, MAX, V, XY, dkLen, err, j, key, lim, lph, out, progress_hook, ret, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
      MAX = 0xffffffff;
      err = ret = null;
      err = dkLen > MAX ? err = new Error("asked for too much data") : this.r * this.p >= (1 << 30) ? new Error("r & p are too big") : (this.r > MAX / 128 / this.p) || (this.r > MAX / 256) || (this.N > MAX / 128 / this.r) ? new Error("N is too big") : null;
      XY = new Uint8Array(256 * this.r);
      V = new Uint8Array(128 * this.r * this.N);
      lim = 128 * this.r;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/scrypt.iced",
          funcname: "Scrypt.run"
        });
        _this.pbkdf2({
          key: key.clone(),
          salt: salt,
          c: _this.c,
          dkLen: lim * _this.p
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return B = arguments[0];
            };
          })(),
          lineno: 175
        }));
        __iced_deferrals._fulfill();
      })(function() {
        B = B.to_ui8a();
        lph = function(j) {
          return function(i) {
            return typeof progress_hook === "function" ? progress_hook({
              i: i + j * _this.N * 2,
              what: "scrypt",
              total: _this.p * _this.N * 2
            }) : void 0;
          };
        };
        (function(__iced_k) {
          var _i, _results, _while;
          j = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++j;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(j < _this.p)) {
              return _break();
            } else {

              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/scrypt.iced",
                  funcname: "Scrypt.run"
                });
                _this.smix({
                  B: B.subarray(lim * j),
                  V: V,
                  XY: XY,
                  progress_hook: lph(j)
                }, __iced_deferrals.defer({
                  lineno: 180
                }));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/scrypt.iced",
              funcname: "Scrypt.run"
            });
            _this.pbkdf2({
              key: key,
              salt: WordArray.from_ui8a(B),
              c: _this.c,
              dkLen: dkLen
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return out = arguments[0];
                };
              })(),
              lineno: 182
            }));
            __iced_deferrals._fulfill();
          })(function() {
            scrub_vec(B);
            scrub_vec(XY);
            scrub_vec(V);
            key.scrub();
            return cb(out);
          });
        });
      });
    };

    return Scrypt;

  })();

  scrypt = function(_arg, cb) {
    var N, c, dkLen, eng, key, klass, p, progress_hook, r, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, salt = _arg.salt, r = _arg.r, N = _arg.N, p = _arg.p, c = _arg.c, klass = _arg.klass, progress_hook = _arg.progress_hook, dkLen = _arg.dkLen;
    eng = new Scrypt({
      r: r,
      N: N,
      p: p,
      c: c,
      klass: klass
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/scrypt.iced",
        funcname: "scrypt"
      });
      eng.run({
        key: key,
        salt: salt,
        progress_hook: progress_hook,
        dkLen: dkLen
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return wa = arguments[0];
          };
        })(),
        lineno: 210
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(wa);
    });
  };

  exports.Scrypt = Scrypt;

  exports.scrypt = scrypt;

}).call(this);
