// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var HMAC, SHA512;



  SHA512 = require('./sha512').SHA512;

  exports.HMAC = HMAC = (function() {
    HMAC.keySize = 512 / 8;

    HMAC.prototype.keySize = HMAC.keySize;

    HMAC.outputSize = 512 / 8;

    HMAC.prototype.outputSize = HMAC.outputSize;

    function HMAC(key, klass) {
      var i, _i, _ref;
      this.key = key;
      if (klass == null) {
        klass = SHA512;
      }
      this.hasher = new klass();
      this.hasherBlockSize = this.hasher.blockSize;
      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
      if (this.key.sigBytes > this.hasherBlockSizeBytes) {
        this.key = this.hasher.finalize(this.key);
      }
      this.key.clamp();
      this._oKey = this.key.clone();
      this._iKey = this.key.clone();
      for (i = _i = 0, _ref = this.hasherBlockSize; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this._oKey.words[i] ^= 0x5c5c5c5c;
        this._iKey.words[i] ^= 0x36363636;
      }
      this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
      this.reset();
    }

    HMAC.prototype.get_output_size = function() {
      return this.hasher.output_size;
    };

    HMAC.prototype.reset = function() {
      return this.hasher.reset().update(this._iKey);
    };

    HMAC.prototype.update = function(wa) {
      this.hasher.update(wa);
      return this;
    };

    HMAC.prototype.finalize = function(wa) {
      var innerHash;
      innerHash = this.hasher.finalize(wa);
      this.hasher.reset();
      return this.hasher.finalize(this._oKey.clone().concat(innerHash));
    };

    return HMAC;

  })();

  exports.sign = function(_arg) {
    var input, key;
    key = _arg.key, input = _arg.input;
    return (new HMAC(key)).finalize(input.clamp());
  };

}).call(this);
